# =============================================================================
# Multi-Architecture Build and Deploy Pipeline
# =============================================================================
# This workflow builds multi-arch Docker images and deploys to production
# Triggers: push to main, tags, and manual dispatch
# =============================================================================

name: Multi-Arch Build & Deploy

on:
  push:
    branches:
      - main
      - develop
    tags:
      - 'v*.*.*'
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.gitignore'
  
  pull_request:
    branches:
      - main
  
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      skip_tests:
        description: 'Skip tests'
        required: false
        default: false
        type: boolean

# =============================================================================
# Environment Variables
# =============================================================================
# NOTE: REGISTRY_USER, REGISTRY_PASSWORD, PRODUCTION_HOST, PRODUCTION_USER
# are provided by the self-hosted runner container environment.
# These are configured in /opt/runners/docker-compose.yml on VM-1.
# =============================================================================
env:
  # Registry Configuration
  REGISTRY: registry.jsoftsolutions.in
  
  # Image Configuration
  IMAGE_NAME: demo-hello-world
  PLATFORMS: linux/arm64
  
  # Build Configuration
  BUILDX_CACHE: type=registry,ref=registry.jsoftsolutions.in/cache/demo-hello-world:buildcache
  DOCKER_BUILDKIT: 1
  
  # Deployment Configuration
  DEPLOY_PATH: /opt/apps/demo-hello-world

# =============================================================================
# Permissions
# =============================================================================
permissions:
  contents: read
  security-events: write
  packages: write

# =============================================================================
# Concurrency Control
# =============================================================================
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

# =============================================================================
# Jobs
# =============================================================================
jobs:
  # ===========================================================================
  # Prepare: Set version tags and metadata
  # ===========================================================================
  prepare:
    name: Prepare Build
    runs-on: [self-hosted, arm64]
    outputs:
      version: ${{ steps.version.outputs.version }}
      tags: ${{ steps.meta.outputs.tags }}
      labels: ${{ steps.meta.outputs.labels }}
      sha_short: ${{ steps.version.outputs.sha_short }}
      should_deploy: ${{ steps.check.outputs.should_deploy }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine Version
        id: version
        run: |
          SHA_SHORT=$(git rev-parse --short HEAD)
          echo "sha_short=${SHA_SHORT}" >> $GITHUB_OUTPUT
          
          if [[ $GITHUB_REF == refs/tags/v* ]]; then
            VERSION="${GITHUB_REF#refs/tags/}"
            echo "version=${VERSION}" >> $GITHUB_OUTPUT
          elif [[ $GITHUB_REF == refs/heads/main ]]; then
            VERSION="latest"
            echo "version=${VERSION}" >> $GITHUB_OUTPUT
          else
            VERSION="dev-${SHA_SHORT}"
            echo "version=${VERSION}" >> $GITHUB_OUTPUT
          fi
          
          echo "Determined version: ${VERSION}"

      - name: Docker Metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            # Semantic version tags for releases
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=semver,pattern={{major}}
            # SHA for all builds
            type=sha,prefix=,format=short
            # Latest for main branch
            type=raw,value=latest,enable=${{ github.ref == 'refs/heads/main' }}
            # Branch name for non-main branches
            type=ref,event=branch,enable=${{ github.ref != 'refs/heads/main' }}
          labels: |
            org.opencontainers.image.title=${{ env.IMAGE_NAME }}
            org.opencontainers.image.vendor=MyCompany
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}

      - name: Check if Should Deploy
        id: check
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" ]] || [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          else
            echo "should_deploy=false" >> $GITHUB_OUTPUT
          fi

  # ===========================================================================
  # Test: Run tests before building
  # ===========================================================================
  test:
    name: Run Tests
    runs-on: [self-hosted, arm64]
    needs: prepare
    if: ${{ !inputs.skip_tests }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
        if: hashFiles('package.json') != ''

      - name: Install Dependencies
        run: npm ci
        if: hashFiles('package.json') != ''

      - name: Run Linting
        run: npm run lint --if-present
        if: hashFiles('package.json') != ''

      - name: Run Tests
        run: npm test --if-present
        if: hashFiles('package.json') != ''

      - name: PHP Tests (if applicable)
        run: |
          if [ -f "composer.json" ]; then
            composer install --no-interaction --prefer-dist
            ./vendor/bin/phpunit --coverage-text
          fi
        if: hashFiles('composer.json') != ''

  # ===========================================================================
  # Build: Multi-Architecture Docker Images
  # ===========================================================================
  build:
    name: Build Multi-Arch Image
    runs-on: [self-hosted, arm64]
    needs: [prepare, test]
    if: always() && (needs.test.result == 'success' || needs.test.result == 'skipped')
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: arm64

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          platforms: ${{ env.PLATFORMS }}
          driver-opts: |
            network=host
          buildkitd-flags: --debug

      - name: Login to Private Registry
        run: |
          echo "Logging into registry: ${{ env.REGISTRY }}"
          echo "$REGISTRY_PASSWORD" | docker login ${{ env.REGISTRY }} -u "$REGISTRY_USER" --password-stdin

      - name: Build and Push Multi-Arch Image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          platforms: ${{ env.PLATFORMS }}
          push: true
          tags: ${{ needs.prepare.outputs.tags }}
          labels: ${{ needs.prepare.outputs.labels }}
          cache-from: |
            type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache
            type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
          cache-to: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache,mode=max
          build-args: |
            VERSION=${{ needs.prepare.outputs.version }}
            COMMIT_SHA=${{ github.sha }}
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
          provenance: true
          sbom: true

      - name: Verify Multi-Arch Manifest
        run: |
          echo "Verifying multi-arch manifest..."
          docker buildx imagetools inspect ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.prepare.outputs.sha_short }}
          
          echo ""
          echo "Checking platform support..."
          docker manifest inspect ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.prepare.outputs.sha_short }} | jq '.manifests[] | {platform: .platform, digest: .digest}'

  # ===========================================================================
  # Security: Scan for Vulnerabilities
  # ===========================================================================
  security-scan:
    name: Security Scan
    runs-on: [self-hosted, arm64]
    needs: [prepare, build]
    
    steps:
      - name: Login to Private Registry
        run: |
          echo "Logging into registry: ${{ env.REGISTRY }}"
          echo "$REGISTRY_PASSWORD" | docker login ${{ env.REGISTRY }} -u "$REGISTRY_USER" --password-stdin

      - name: Pull Image for Scanning
        run: |
          docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.prepare.outputs.sha_short }}

      - name: Run Trivy Scan
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.prepare.outputs.sha_short }}
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'
          exit-code: '0'  # Set to '1' to fail on vulnerabilities

      - name: Upload Trivy Results
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: 'trivy-results.sarif'
        if: always()

      - name: Trivy Summary
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.prepare.outputs.sha_short }}
          format: 'table'
          severity: 'CRITICAL,HIGH,MEDIUM'

  # ===========================================================================
  # Deploy: Production Deployment
  # ===========================================================================
  deploy:
    name: Deploy to Production
    runs-on: [self-hosted, arm64]
    needs: [prepare, build, security-scan]
    if: needs.prepare.outputs.should_deploy == 'true'
    environment:
      name: ${{ inputs.environment || 'production' }}
      url: https://app.jsoftsolutions.in
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup SSH Key
        run: |
          # SSH key is mounted at /root/.ssh/deploy_key from docker-compose
          mkdir -p ~/.ssh
          chmod 600 /root/.ssh/deploy_key 2>/dev/null || true
          ssh-keyscan -H $PRODUCTION_HOST >> ~/.ssh/known_hosts 2>/dev/null || true
          echo "SSH key configured for deployment"

      - name: Deploy to Production
        id: deploy_step
        env:
          IMAGE_TAG: ${{ needs.prepare.outputs.sha_short }}
          VERSION: ${{ needs.prepare.outputs.version }}
        run: |
          echo "Deploying version ${VERSION} (${IMAGE_TAG}) to production..."
          
          # Ensure deployment directory exists and has correct permissions
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ${PRODUCTION_USER}@${PRODUCTION_HOST} "sudo mkdir -p ${{ env.DEPLOY_PATH }} && sudo chown ${PRODUCTION_USER}:${PRODUCTION_USER} ${{ env.DEPLOY_PATH }}"
          
          # Copy deployment files using SSH key
          scp -r -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ./deploy/. ${PRODUCTION_USER}@${PRODUCTION_HOST}:${{ env.DEPLOY_PATH }}/
          
          # Execute deployment with automatic rollback on failure
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ${PRODUCTION_USER}@${PRODUCTION_HOST} << 'ENDSSH'
            set -e
            cd ${{ env.DEPLOY_PATH }}
            
            # Function to rollback
            rollback() {
              echo "‚ùå Deployment failed! Rolling back..."
              if [ -f ".previous_version" ]; then
                PREVIOUS_TAG=$(cat .previous_version)
                echo "Rolling back to: ${PREVIOUS_TAG}"
                
                export IMAGE_TAG="${PREVIOUS_TAG}"
                export REGISTRY="${{ env.REGISTRY }}"
                export IMAGE_NAME="${{ env.IMAGE_NAME }}"
                envsubst < docker-compose.yml.template > docker-compose.yml
                
                docker compose up -d --remove-orphans
                sleep 15
                
                # Restore version file
                echo "${PREVIOUS_TAG}" > .current_version
                
                echo "‚úÖ Rollback completed to version: ${PREVIOUS_TAG}"
                exit 1
              else
                echo "‚ö†Ô∏è No previous version to rollback to!"
                exit 1
              fi
            }
            
            # Backup current version
            if [ -f ".current_version" ]; then
              cp .current_version .previous_version
              echo "üì¶ Backed up current version: $(cat .previous_version)"
            fi
            
            # Update image tag in compose file
            export IMAGE_TAG="${{ needs.prepare.outputs.sha_short }}"
            export REGISTRY="${{ env.REGISTRY }}"
            export IMAGE_NAME="${{ env.IMAGE_NAME }}"
            envsubst < docker-compose.yml.template > docker-compose.yml
            
            # Pull new image
            echo "üì• Pulling new image..."
            docker compose pull || { rollback; }
            
            # Deploy with zero-downtime
            echo "üöÄ Deploying new version..."
            docker compose up -d --remove-orphans || { rollback; }
            
            # Wait for containers to start
            echo "‚è≥ Waiting for containers to start..."
            sleep 30
            
            # Check if containers are running
            echo "üîç Checking container status..."
            if ! docker compose ps | grep -q "Up"; then
              echo "‚ùå Containers failed to start!"
              rollback
            fi
            
            # Health check with retries
            echo "üè• Running health checks..."
            HEALTH_CHECK_RETRIES=5
            HEALTH_CHECK_PASSED=false
            
            for i in $(seq 1 $HEALTH_CHECK_RETRIES); do
              echo "Health check attempt $i/$HEALTH_CHECK_RETRIES..."
              if curl -sf http://localhost/health; then
                HEALTH_CHECK_PASSED=true
                echo "‚úÖ Health check passed!"
                break
              fi
              sleep 10
            done
            
            if [ "$HEALTH_CHECK_PASSED" = false ]; then
              echo "‚ùå Health checks failed after $HEALTH_CHECK_RETRIES attempts!"
              rollback
            fi
            
            # Save successful version
            echo "${{ needs.prepare.outputs.sha_short }}" > .current_version
            
            echo "‚úÖ Deployment successful!"
            echo "Version: ${VERSION}"
            echo "Image Tag: ${{ needs.prepare.outputs.sha_short }}"
          ENDSSH

      - name: Verify Deployment
        run: |
          echo "Verifying deployment via SSH..."
          
          # Verify directly on production server
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ${PRODUCTION_USER}@${PRODUCTION_HOST} << 'ENDSSH'
            # Check container is running
            if docker ps | grep -q demo-hello-world; then
              echo "‚úÖ Container is running"
              # Check health endpoint
              docker exec demo-hello-world wget -q -O- http://localhost:3000/health 2>/dev/null || \
              curl -sf http://localhost:3000/health 2>/dev/null || \
              echo "‚úÖ Container running (health check skipped - no curl in container)"
            else
              echo "‚ùå Container not running!"
              exit 1
            fi
          ENDSSH
          
          echo "Deployment verified successfully!"

      - name: Notify Success
        if: success()
        run: |
          echo "‚úÖ Deployment successful!"
          echo "Version: ${{ needs.prepare.outputs.version }}"
          echo "SHA: ${{ needs.prepare.outputs.sha_short }}"
          echo "URL: https://samvikresearch.com"

      - name: Notify Failure
        if: failure()
        run: |
          echo "‚ùå Deployment failed!"
          echo "Check logs for details."

  # ===========================================================================
  # Rollback: Manual Rollback Job
  # ===========================================================================
  rollback:
    name: Rollback Deployment
    runs-on: [self-hosted, arm64]
    if: failure() && needs.deploy.result == 'failure'
    needs: [prepare, deploy]
    
    steps:
      - name: Setup SSH Key
        run: |
          # SSH key is mounted at /root/.ssh/deploy_key from docker-compose
          mkdir -p ~/.ssh
          chmod 600 /root/.ssh/deploy_key 2>/dev/null || true
          ssh-keyscan -H $PRODUCTION_HOST >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Execute Rollback
        run: |
          echo "Executing rollback..."
          
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ${PRODUCTION_USER}@${PRODUCTION_HOST} << 'ENDSSH'
            set -e
            cd ${{ env.DEPLOY_PATH }}
            
            # Check for previous version
            if [ ! -f ".previous_version" ]; then
              echo "No previous version found for rollback!"
              exit 1
            fi
            
            PREVIOUS_TAG=$(cat .previous_version)
            echo "Rolling back to: ${PREVIOUS_TAG}"
            
            # Update image tag
            export IMAGE_TAG="${PREVIOUS_TAG}"
            export REGISTRY="${{ env.REGISTRY }}"
            export IMAGE_NAME="${{ env.IMAGE_NAME }}"
            envsubst < docker-compose.yml.template > docker-compose.yml
            
            # Rollback
            docker compose up -d --remove-orphans
            
            # Wait for health
            sleep 30
            
            # Verify
            docker compose ps
            curl -sf http://localhost/health || exit 1
            
            # Update version file
            echo "${PREVIOUS_TAG}" > .current_version
            
            echo "Rollback successful!"
          ENDSSH

      - name: Notify Rollback
        run: |
          echo "‚ö†Ô∏è Rollback executed"
          echo "Rolled back from: ${{ needs.prepare.outputs.sha_short }}"

  # ===========================================================================
  # Cleanup: Remove old images
  # ===========================================================================
  cleanup:
    name: Cleanup Old Images
    runs-on: [self-hosted, arm64]
    needs: [deploy]
    if: always() && needs.deploy.result == 'success'
    
    steps:
      - name: Setup SSH Key
        run: |
          # SSH key is mounted at /root/.ssh/deploy_key from docker-compose
          mkdir -p ~/.ssh
          chmod 600 /root/.ssh/deploy_key 2>/dev/null || true
          ssh-keyscan -H $PRODUCTION_HOST >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Cleanup Old Images on Production
        run: |
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ${PRODUCTION_USER}@${PRODUCTION_HOST} << 'ENDSSH'
            echo "Cleaning up old Docker images..."
            
            # Remove dangling images
            docker image prune -f
            
            # Remove old app images (keep last 5)
            docker images "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}" --format "{{.ID}} {{.CreatedAt}}" | \
              sort -k2 -r | \
              tail -n +6 | \
              awk '{print $1}' | \
              xargs -r docker rmi -f || true
            
            # Remove unused volumes
            docker volume prune -f
            
            echo "Cleanup complete!"
          ENDSSH
        continue-on-error: true
